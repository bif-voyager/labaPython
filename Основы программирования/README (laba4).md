
## Задание

1. Реализовать замыкание для поиска среднего значения по переданным аргументам.

2. Реализовать декоратор для проверки аргументов функции:
    - на тип (должны быть числа);
    - на попадание в заданный диапазон значений.
3. Применить декоратор к замыканию из пункта 1.
4. Оформить отчёт и продемонстрировать работу программ.

---
## Описание проделанной работы

В рамках лабораторной работы были реализованы:

1. Декоратор `check_args`, который:
    - проверяет, что все позиционные аргументы относятся к допустимым типам (по умолчанию `int` и `float`);
    - проверяет, что аргументы не выходят за границы заданного диапазона `[min_value, max_value]`;
    - в случае нарушения условий выбрасывает:
        - `TypeError` — если тип аргумента неверный;
        - `ValueError` — если аргумент выходит за границы.
2. Фабрика замыканий `make_averager`, которая:
    - создаёт и возвращает внутреннюю функцию `averager`;
    - `averager` принимает произвольное количество числовых аргументов;
    - внутри замыкания хранятся накопленные сумма и количество (`total`, `count`);
    - при каждом вызове добавляются новые значения и пересчитывается среднее;
    - к `averager` применён декоратор `check_args`, поэтому все входные значения проходят проверку.

Таким образом, показано совместное использование замыкания (для хранения состояния между вызовами) и декоратора (для валидации входных данных).

---

## Код программы

### Декоратор для проверки аргументов

```python
from functools import wraps
from typing import Union, Tuple, Callable

Number = Union[int, float]

def check_args(arg_types: Tuple[type, ...] = (int, float),
               min_value: Number | None = None,
               max_value: Number | None = None) -> Callable:
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            for x in args:
                if not isinstance(x, arg_types):
                    raise TypeError(
                        f"Недопустимый тип аргумента {x!r}: "
                        f"ожидались типы {arg_types}, получен {type(x)}"
                    )
                if min_value is not None and x < min_value:
                    raise ValueError(
                        f"Аргумент {x!r} меньше минимально допустимого {min_value}"
                    )
                if max_value is not None and x > max_value:
                    raise ValueError(
                        f"Аргумент {x!r} больше максимально допустимого {max_value}"
                    )
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### Замыкание для поиска среднего

```python
def make_averager(min_value: Number | None = None,
                  max_value: Number | None = None):
    total = 0.0
    count = 0

    @check_args((int, float), min_value=min_value, max_value=max_value)
    def averager(*values: Number) -> float:
        nonlocal total, count
        for v in values:
            total += v
            count += 1
        if count == 0:
            raise ZeroDivisionError("Нельзя вычислить среднее без значений")
        return total / count

    return averager
```

### Демонстрация работы

```python
if __name__ == "__main__":
    # Замыкание, принимающее числа только от 0 до 100
    avg = make_averager(min_value=0, max_value=100)

    print("Добавляем 10, 20, 30...")
    print("Среднее:", avg(10, 20, 30))

    print("Добавляем ещё 40...")
    print("Новое среднее:", avg(40))

    print("Пробуем добавить недопустимое значение -5...")
    try:
        avg(-5)
    except Exception as e:
        print("Ожидаемая ошибка:", e)

    print("Пробуем передать строку...")
    try:
        avg("100")  # тип int/float не соблюдён
    except Exception as e:
        print("Ожидаемая ошибка:", e)
```

---
## Результаты работы программы

Пример запуска:

```
Добавляем 10, 20, 30...
Среднее: 20.0
Добавляем ещё 40...
Новое среднее: 25.0
Пробуем добавить недопустимое значение -5...
Ожидаемая ошибка: Аргумент -5 меньше минимально допустимого 0
Пробуем передать строку...
Ожидаемая ошибка: Недопустимый тип аргумента '100': ожидались типы (<class 'int'>, <class 'float'>), получен <class 'str'>
```

**Комментарий к результатам:**

- После добавления значений `10, 20, 30` среднее равно `(10 + 20 + 30) / 3 = 20.0`.
    
- После добавления `40` среднее становится `(10 + 20 + 30 + 40) / 4 = 25.0`.
    
- Значение `-5` отклоняется декоратором как выходящее за пределы диапазона `[0, 100]`.
    
- Строка `"100"` отклоняется декоратором как аргумент недопустимого типа.
    

Это подтверждает корректную работу и замыкания, и декоратора.

---
## Скриншоты результатов

![[Pasted image 20251113172750.png]]

---
## Вывод

В ходе лабораторной работы были изучены и реализованы:

- замыкание для хранения состояния (сумма и количество введённых чисел);
- декоратор для проверки типов и диапазона аргументов;
- применение декоратора к функции-замыканию.

Полученные результаты показывают, что такая комбинация позволяет создавать безопасные и удобно повторно используемые вычислительные объекты: логика работы замыкания отделена от логики валидации входных данных.

---
## Список использованных источников

1. [Замыкания и декораторы в Python: часть 1 — замыкания](https://habr.com/ru/articles/781866/)
2. [Замыкания и декораторы в Python: часть 2 — замыкания](https://habr.com/ru/articles/800239/)
